{
  "title": "Build Shopping Cart promotion engine with boolean expressions",
  "date": "2020-06-06T00:00:00.000Z",
  "tags": [
    "parser-generator",
    "PEG-parser",
    "compiler-design",
    "promotion-engine"
  ],
  "summary": "Build a promotions evalution engine based on target and qualifiers defined via an expression language.\r",
  "body": {
    "raw": "\r\nBuild Shopping Cart promotion engine with boolean expressions\r\nsamarjit.samanta\r\nsamarjit.samanta\r\n\r\n3 min read\r\n·\r\nJul 6, 2020\r\n\r\n\r\n\r\n\r\n\r\nBoolean expression parser as we built in the previous post is used to create a domain specific language DSL. In this post we will see how to evaluate such DSL. Here we modified the language slightly to make it fit for building a promotion engine. Under the hood, we are still going to use a PEG.js based grammar. If you are unclear about how to write basic grammar I highly recommend reading the previous post.\r\n\r\nA promotion needs to match a cart with several conditions satisfied. A very succinct way of defining all the conditions is to define it as a complex boolean expression. In this chapter we are going to look at how to evaluate such boolean expression. But lets first see how the expression might look like.\r\n\r\n> Expression\r\n> Promotion1:\r\n> \r\n> Buy 2 iphone and get $400 off\r\n> productCount(productModel=\"IPHONE\") > 1\r\n> \r\n> Promotion2:\r\n> \r\n> Buy any phone and a phone case and get $50 off\r\n> \r\n> productExists(productType=\"PHONE\" and price > 600) and productExists(productType=\"CASE\")\r\n\r\n\r\nLets breakdown the expression to see the concept behind it. Instead of calling these as regular functions lets call them as selector functions. The argument these functions take is basically a line-item selector. The function operates on the selected line-item. So productModel=\"IPHONE\" is the line-item selector. This is not an assignment operation, the equal symbol is a logical equality checker. Left hand side is a property and right hand side is a constant with which the property is matched. This property is expected to be present in each line-item (context). So this expression can be evaluated on any context which has these properties productModel, productType and price.\r\n\r\nContext/Line-Item\r\nLets create a context to evaluate the above expression.\r\n\r\n```\r\nLine 1: {\"productType\":\"PHONE\",\"productModel\":\"IPHONE\",\"price\":800}\r\nLine 2: {\"productType\":\"CASE\",\"productModel\":\"ClearCase\",\"price\":20}\r\n```\r\nNow let see how the above expressions should behave. For promotion1 to be satisfied two of the line-item must be a IPHONE. We have only one IPHONE in our context so the promotion1 should evaluate to false. For the promotion2 however any phone with price more than 600 should match line1. The second part is that one of the line-items must contain a CASE. So since both the conditions are matching promotion2 must should evaluate to true.\r\n\r\nRules Engine\r\nThe rules engine consists of expression tree traversal and start evaluation from the leaf nodes. Then as we go higher up in the tree combine the result from the level below and so on. Eventually at the end of traversal when you reach the root node you will have some boolean value left. That should be the result of the entire expression. Another way to look at it is, assume the expression tree to be a prefixed expression. Prefix expression evaluation seems to fit machines very well. Eg. ‘-AB’. read ‘-’ push it onto stack. After that machine knows how many variables to read before evaluation. For unary operator only one variable is required for binary two variables in this case ‘A’ and ‘B’.\r\n\r\nThe selector function is context specific. In our case the selector portion knows how to iterate over the line-items, and pass each line-item for selector expression evaluation. This is how the pseudo code would look like\r\n\r\n```\r\nfunction evalRule(rule, context) {\r\nhandle rule for primitive operators and context\r\n// recursively call child rules\r\nhandle rule for nested operator. call evalRule(childRule, context)\r\nhandle rule for selector functions\r\n     loop over context line-items\r\n        evalRule(selectorRule, line-items)\r\n        aggregate results based on type of function\r\n}\r\n```\r\n\r\nInteractive Example\r\nFinally lets see some interactive examples. You can make the changes to product line-items to match our promotion1, by adding another IPHONE line-item to the cart. Add to cart is simple, just select a product from product list and all selected products make up the cart.\r\n\r\nIf you are interested further you can create your own promotion to match the line items, or match new line-items that you can create.\r\n\r\n\r\n",
    "code": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var k=Object.getPrototypeOf,N=Object.prototype.hasOwnProperty;var g=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),f=(a,e)=>{for(var t in e)s(a,t,{get:e[t],enumerable:!0})},i=(a,e,t,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!N.call(a,o)&&o!==t&&s(a,o,{get:()=>e[o],enumerable:!(r=m(e,o))||r.enumerable});return a};var y=(a,e,t)=>(t=a!=null?d(k(a)):{},i(e||!a||!a.__esModule?s(t,\"default\",{value:a,enumerable:!0}):t,a)),w=a=>i(s({},\"__esModule\",{value:!0}),a);var c=g((E,l)=>{l.exports=_jsx_runtime});var b={};f(b,{default:()=>h,frontmatter:()=>x});var n=y(c()),x={title:\"Build Shopping Cart promotion engine with boolean expressions\",date:\"2020-06-06\",tags:[\"parser-generator\",\"PEG-parser\",\"compiler-design\",\"promotion-engine\"],summary:\"Build a promotions evalution engine based on target and qualifiers defined via an expression language.\"};function p(a){let e={blockquote:\"blockquote\",code:\"code\",p:\"p\",pre:\"pre\",span:\"span\",...a.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Build Shopping Cart promotion engine with boolean expressions samarjit.samanta samarjit.samanta\"}),(0,n.jsx)(e.p,{children:\"3 min read \\xB7 Jul 6, 2020\"}),(0,n.jsx)(e.p,{children:\"Boolean expression parser as we built in the previous post is used to create a domain specific language DSL. In this post we will see how to evaluate such DSL. Here we modified the language slightly to make it fit for building a promotion engine. Under the hood, we are still going to use a PEG.js based grammar. If you are unclear about how to write basic grammar I highly recommend reading the previous post.\"}),(0,n.jsx)(e.p,{children:\"A promotion needs to match a cart with several conditions satisfied. A very succinct way of defining all the conditions is to define it as a complex boolean expression. In this chapter we are going to look at how to evaluate such boolean expression. But lets first see how the expression might look like.\"}),(0,n.jsxs)(e.blockquote,{children:[(0,n.jsx)(e.p,{children:\"Expression Promotion1:\"}),(0,n.jsx)(e.p,{children:'Buy 2 iphone and get $400 off productCount(productModel=\"IPHONE\") > 1'}),(0,n.jsx)(e.p,{children:\"Promotion2:\"}),(0,n.jsx)(e.p,{children:\"Buy any phone and a phone case and get $50 off\"}),(0,n.jsx)(e.p,{children:'productExists(productType=\"PHONE\" and price > 600) and productExists(productType=\"CASE\")'})]}),(0,n.jsx)(e.p,{children:'Lets breakdown the expression to see the concept behind it. Instead of calling these as regular functions lets call them as selector functions. The argument these functions take is basically a line-item selector. The function operates on the selected line-item. So productModel=\"IPHONE\" is the line-item selector. This is not an assignment operation, the equal symbol is a logical equality checker. Left hand side is a property and right hand side is a constant with which the property is matched. This property is expected to be present in each line-item (context). So this expression can be evaluated on any context which has these properties productModel, productType and price.'}),(0,n.jsx)(e.p,{children:\"Context/Line-Item Lets create a context to evaluate the above expression.\"}),(0,n.jsx)(e.pre,{className:\"language-js\",children:(0,n.jsxs)(e.code,{className:\"language-js code-highlight\",children:[(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token maybe-class-name\",children:\"Line\"}),\" \",(0,n.jsx)(e.span,{className:\"token number\",children:\"1\"}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),\" \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"{\"}),(0,n.jsx)(e.span,{className:\"token property string-property\",children:'\"productType\"'}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),(0,n.jsx)(e.span,{className:\"token string\",children:'\"PHONE\"'}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\",\"}),(0,n.jsx)(e.span,{className:\"token property string-property\",children:'\"productModel\"'}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),(0,n.jsx)(e.span,{className:\"token string\",children:'\"IPHONE\"'}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\",\"}),(0,n.jsx)(e.span,{className:\"token property string-property\",children:'\"price\"'}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),(0,n.jsx)(e.span,{className:\"token number\",children:\"800\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"}\"}),`\\r\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token maybe-class-name\",children:\"Line\"}),\" \",(0,n.jsx)(e.span,{className:\"token number\",children:\"2\"}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),\" \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"{\"}),(0,n.jsx)(e.span,{className:\"token property string-property\",children:'\"productType\"'}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),(0,n.jsx)(e.span,{className:\"token string\",children:'\"CASE\"'}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\",\"}),(0,n.jsx)(e.span,{className:\"token property string-property\",children:'\"productModel\"'}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),(0,n.jsx)(e.span,{className:\"token string\",children:'\"ClearCase\"'}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\",\"}),(0,n.jsx)(e.span,{className:\"token property string-property\",children:'\"price\"'}),(0,n.jsx)(e.span,{className:\"token operator\",children:\":\"}),(0,n.jsx)(e.span,{className:\"token number\",children:\"20\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})]})}),(0,n.jsx)(e.p,{children:\"Now let see how the above expressions should behave. For promotion1 to be satisfied two of the line-item must be a IPHONE. We have only one IPHONE in our context so the promotion1 should evaluate to false. For the promotion2 however any phone with price more than 600 should match line1. The second part is that one of the line-items must contain a CASE. So since both the conditions are matching promotion2 must should evaluate to true.\"}),(0,n.jsx)(e.p,{children:\"Rules Engine The rules engine consists of expression tree traversal and start evaluation from the leaf nodes. Then as we go higher up in the tree combine the result from the level below and so on. Eventually at the end of traversal when you reach the root node you will have some boolean value left. That should be the result of the entire expression. Another way to look at it is, assume the expression tree to be a prefixed expression. Prefix expression evaluation seems to fit machines very well. Eg. \\u2018-AB\\u2019. read \\u2018-\\u2019 push it onto stack. After that machine knows how many variables to read before evaluation. For unary operator only one variable is required for binary two variables in this case \\u2018A\\u2019 and \\u2018B\\u2019.\"}),(0,n.jsx)(e.p,{children:\"The selector function is context specific. In our case the selector portion knows how to iterate over the line-items, and pass each line-item for selector expression evaluation. This is how the pseudo code would look like\"}),(0,n.jsx)(e.pre,{className:\"language-js\",children:(0,n.jsxs)(e.code,{className:\"language-js code-highlight\",children:[(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token keyword\",children:\"function\"}),\" \",(0,n.jsx)(e.span,{className:\"token function\",children:\"evalRule\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),(0,n.jsxs)(e.span,{className:\"token parameter\",children:[\"rule\",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\",\"}),\" context\"]}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"{\"}),`\\r\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"handle rule \",(0,n.jsx)(e.span,{className:\"token keyword control-flow\",children:\"for\"}),` primitive operators and context\\r\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token comment\",children:\"// recursively call child rules\"}),`\\r\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"handle rule \",(0,n.jsx)(e.span,{className:\"token keyword control-flow\",children:\"for\"}),\" nested operator\",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\".\"}),\" \",(0,n.jsx)(e.span,{className:\"token property-access\",children:\"call\"}),\" \",(0,n.jsx)(e.span,{className:\"token function\",children:\"evalRule\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),\"childRule\",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\",\"}),\" context\",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),`\\r\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"handle rule \",(0,n.jsx)(e.span,{className:\"token keyword control-flow\",children:\"for\"}),` selector functions\\r\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"     loop over context line\",(0,n.jsx)(e.span,{className:\"token operator\",children:\"-\"}),`items\\r\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"        \",(0,n.jsx)(e.span,{className:\"token function\",children:\"evalRule\"}),(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"(\"}),\"selectorRule\",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\",\"}),\" line\",(0,n.jsx)(e.span,{className:\"token operator\",children:\"-\"}),\"items\",(0,n.jsx)(e.span,{className:\"token punctuation\",children:\")\"}),`\\r\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"        aggregate results based on type \",(0,n.jsx)(e.span,{className:\"token keyword\",children:\"of\"}),\" \",(0,n.jsx)(e.span,{className:\"token keyword\",children:\"function\"}),`\\r\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})]})}),(0,n.jsx)(e.p,{children:\"Interactive Example Finally lets see some interactive examples. You can make the changes to product line-items to match our promotion1, by adding another IPHONE line-item to the cart. Add to cart is simple, just select a product from product list and all selected products make up the cart.\"}),(0,n.jsx)(e.p,{children:\"If you are interested further you can create your own promotion to match the line items, or match new line-items that you can create.\"})]})}function h(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,{...a,children:(0,n.jsx)(p,{...a})}):p(a)}return w(b);})();\n;return Component;"
  },
  "_id": "blog/boolean-expression-promotionengine.mdx",
  "_raw": {
    "sourceFilePath": "blog/boolean-expression-promotionengine.mdx",
    "sourceFileName": "boolean-expression-promotionengine.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/boolean-expression-promotionengine"
  },
  "type": "Blog",
  "readingTime": {
    "text": "4 min read",
    "minutes": 3.345,
    "time": 200700,
    "words": 669
  },
  "slug": "boolean-expression-promotionengine",
  "path": "blog/boolean-expression-promotionengine",
  "filePath": "blog/boolean-expression-promotionengine.mdx",
  "toc": [],
  "structuredData": {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Build Shopping Cart promotion engine with boolean expressions",
    "datePublished": "2020-06-06T00:00:00.000Z",
    "dateModified": "2020-06-06T00:00:00.000Z",
    "description": "Build a promotions evalution engine based on target and qualifiers defined via an expression language.\r",
    "image": "/static/images/twitter-card.png",
    "url": "https://samarjitsamanta.com/blog/boolean-expression-promotionengine"
  }
}