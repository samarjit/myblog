<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF Image Extractor & Rebuilder</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    .img-container { display: flex; flex-wrap: wrap; gap: 8px; }
    .img-container div { border: 1px solid #ccc; padding: 4px; position: relative; }
    .img-container img.thumb-preview { width: 100px; height: auto; cursor: grab; }
    .full-preview-wrapper img { max-width: 100%; height: auto; display: block; margin: 1rem 0; }
    .placeholder { width: 100px; height: 100px; border: 2px dashed #888; background: #eee; display: flex; align-items: center; justify-content: center; font-size: 0.9rem; }
    .dragging { opacity: 0.4; }
  </style>
  <link rel="stylesheet" href="css/bootstrap.css" />
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CKY54F98QE"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-CKY54F98QE');
  </script>
</head>
<body>
<span><a href="/">Home</a></span> <br/>
<h2>1. Upload PDF to Extract Images</h2>
<input type="file" id="pdfInput" accept="application/pdf">

<h2>2. Add More Images</h2>
<input type="file" id="imageInput" multiple accept="image/*">

<h2>3. Reorder Images (Drag & Drop)</h2>
<div id="imageList" class="img-container"></div>

<h2>Full Preview</h2>
<div id="fullPreview" class="full-preview-wrapper"></div>

<h2>4. Create PDF</h2>
<button id="downloadBtn">Download New PDF</button>

<script type="module">
  import { PDFDocument } from 'https://cdn.skypack.dev/pdf-lib';

  const pdfInput = document.getElementById('pdfInput');
  const imageInput = document.getElementById('imageInput');
  const imageList = document.getElementById('imageList');
  const fullPreview = document.getElementById('fullPreview');
  const downloadBtn = document.getElementById('downloadBtn');

  const images = [];

  async function addImage(blobUrl, file) {
    const img = new Image();
    img.src = blobUrl;
    await img.decode();

    const maxWidth = 1024;
    const scale = Math.min(1, maxWidth / img.width);
    const newWidth = img.width * scale;
    const newHeight = img.height * scale;

    const canvas = document.createElement('canvas');
    canvas.width = newWidth;
    canvas.height = newHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, newWidth, newHeight);

    const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.9));
    const compressedBlobUrl = URL.createObjectURL(blob);
    const compressedFile = new File([blob], file.name, { type: 'image/jpeg' });

    images.push({ blobUrl: compressedBlobUrl, file: compressedFile });
    renderImageList();
    renderFullPreview();
  }

  function renderImageList() {
    imageList.innerHTML = '';
    images.forEach((_, index) => renderThumbnail(index));
  }

  function renderThumbnail(index) {
    const { blobUrl } = images[index];

    const container = document.createElement('div');
    container.dataset.index = index;

    const thumb = document.createElement('img');
    thumb.src = blobUrl;
    thumb.className = 'thumb-preview';
    thumb.draggable = true;

    const placeholder = document.createElement('div');
    placeholder.className = 'placeholder';
    placeholder.textContent = 'Drop Here';

    thumb.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', index);
      setTimeout(() => container.classList.add('dragging'), 0);
    });

    thumb.addEventListener('dragend', () => {
      document.querySelectorAll('.placeholder').forEach(p => p.remove());
      document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
    });

    container.addEventListener('dragover', e => {
      e.preventDefault();
      if (!container.querySelector('.placeholder')) {
        container.appendChild(placeholder);
      }
    });

    container.addEventListener('dragleave', () => {
      if (container.contains(placeholder)) {
        container.removeChild(placeholder);
      }
    });

    container.addEventListener('drop', e => {
      e.preventDefault();
      const from = parseInt(e.dataTransfer.getData('text/plain'));
      reorderImages(from, index);
      document.querySelectorAll('.placeholder').forEach(p => p.remove());
    });

    container.appendChild(thumb);
    imageList.appendChild(container);
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.className = 'btn btn-danger btn-sm';
    deleteBtn.addEventListener('click', () => {
      deleteImage(index);
    });
    container.appendChild(deleteBtn)
  }

  function reorderImages(from, to) {
    if (from === to) return;
    const moved = images.splice(from, 1)[0];
    images.splice(to, 0, moved);
    renderImageList();
    renderFullPreview();
  }
  function deleteImage(index) {
    images.splice(index, 1);
    renderImageList();
    renderFullPreview();
  }
  function renderFullPreview() {
    fullPreview.innerHTML = '';
    images.forEach(({ blobUrl }) => {
      const fullImg = document.createElement('img');
      fullImg.src = blobUrl;
      fullPreview.appendChild(fullImg);
    });
  }

  pdfInput.addEventListener('change', async () => {
    const file = pdfInput.files[0];
    const blobUrl = URL.createObjectURL(file);

    const pdf = await pdfjsLib.getDocument(blobUrl).promise;

    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const viewport = page.getViewport({ scale: 2 });
      const canvas = document.createElement('canvas');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const context = canvas.getContext('2d');
      await page.render({ canvasContext: context, viewport }).promise;

      const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg'));
      const imageUrl = URL.createObjectURL(blob);
      const file = new File([blob], `page-${i}.jpg`, { type: 'image/jpeg' });
      await addImage(imageUrl, file);
    }
  });

  imageInput.addEventListener('change', () => {
    [...imageInput.files].forEach(file => {
      const blobUrl = URL.createObjectURL(file);
      addImage(blobUrl, file);
    });
  });

  downloadBtn.addEventListener('click', async () => {
    const pdfDoc = await PDFDocument.create();

    for (const { file } of images) {
      const imgBytes = await file.arrayBuffer();
      const imgExt = file.type === 'image/png' ? 'png' : 'jpg';
      const image = imgExt === 'png'
        ? await pdfDoc.embedPng(imgBytes)
        : await pdfDoc.embedJpg(imgBytes);

      const page = pdfDoc.addPage([image.width, image.height]);
      page.drawImage(image, { x: 0, y: 0, width: image.width, height: image.height });
    }

    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'combined.pdf';
    link.click();
  });

  const script = document.createElement('script');
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
  document.head.appendChild(script);
</script>
</body>
</html>
